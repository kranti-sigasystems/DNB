// scripts/combine-models.ts
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

interface ParsedContent {
  enums: string[];
  models: string[];
}

function combinePrismaModels(): void {
  console.log('üîß Combining Prisma models...\n');

  const modelsDir = path.join(__dirname, '../prisma/models');
  const schemaFile = path.join(__dirname, '../prisma/schema.prisma');

  // Check if models directory exists
  if (!fs.existsSync(modelsDir)) {
    console.error('‚ùå Models directory not found:', modelsDir);
    console.log('Creating models directory...');
    fs.mkdirSync(modelsDir, { recursive: true });
  }

  // Get all .prisma files
  const modelFiles = fs
    .readdirSync(modelsDir)
    .filter((file) => file.endsWith('.prisma'))
    .sort(); // Sort for consistent ordering

  if (modelFiles.length === 0) {
    console.warn('‚ö†Ô∏è  No .prisma files found in models directory');
    console.log('Place your model files in prisma/models/');
    console.log('Example: User.prisma, Plan.prisma, etc.\n');
  }

  // Base schema content
  const baseSchema = `// ============================================
// AUTO-GENERATED - DO NOT EDIT DIRECTLY
// Generated by combine-models.ts
// Date: ${new Date().toLocaleString()}
// ============================================

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`;

  const parsedContent: ParsedContent = {
    enums: [],
    models: [],
  };

  // Parse each model file
  modelFiles.forEach((file) => {
    const filePath = path.join(modelsDir, file);
    const content = fs.readFileSync(filePath, 'utf8');
    const { enums, models } = parsePrismaFile(content, file);

    parsedContent.enums.push(...enums);
    parsedContent.models.push(...models);
  });

  // Write to schema file
  let output = baseSchema;

  if (parsedContent.enums.length > 0) {
    output += `// ============================================\n`;
    output += `// ENUMS\n`;
    output += `// ============================================\n\n`;
    output += parsedContent.enums.join('\n\n');
    output += '\n\n';
  }

  output += `// ============================================\n`;
  output += `// MODELS\n`;
  output += `// ============================================\n\n`;
  output += parsedContent.models.join('\n\n');

  fs.writeFileSync(schemaFile, output);

  console.log('‚úÖ Schema generation complete!\n');
  console.log('üìä Statistics:');
  console.log(`   Model files processed: ${modelFiles.length}`);
  console.log(`   Enums extracted: ${parsedContent.enums.length}`);
  console.log(`   Models extracted: ${parsedContent.models.length}`);
  console.log(`   Output file: ${schemaFile}\n`);
  console.log('‚ö° Next steps:');
  console.log('   1. Run: npm run prisma:generate');
  console.log('   2. Run: npm run prisma:migrate\n');

  // Optionally run prisma generate automatically
  const shouldGenerate = process.argv.includes('--generate');
  if (shouldGenerate) {
    console.log('üöÄ Running prisma generate...');
    try {
      execSync('npx prisma generate', { stdio: 'inherit' });
      console.log('‚úÖ Prisma Client generated successfully!');
    } catch (error) {
      console.error('‚ùå Failed to generate Prisma Client');
      if (error instanceof Error) {
        console.error('Error message:', error.message);
      }
    }
  }
}

function parsePrismaFile(content: string, fileName: string): ParsedContent {
  const lines = content.split('\n');
  const result: ParsedContent = {
    enums: [],
    models: [],
  };

  let currentEnum: string[] = [];
  let inEnum = false;
  let currentModel: string[] = [];
  let inModel = false;
  let braceCount = 0;

  for (const line of lines) {
    const trimmed = line.trim();

    if (trimmed.startsWith('enum ')) {
      inEnum = true;
      braceCount = 1;
      currentEnum = [line];
    } else if (trimmed.startsWith('model ')) {
      inModel = true;
      braceCount = 1;
      currentModel = [`// From: ${fileName}`, line];
    } else if (inEnum) {
      currentEnum.push(line);
      // Count braces to handle nested structures (though uncommon in enums)
      braceCount += (line.match(/{/g) || []).length;
      braceCount -= (line.match(/}/g) || []).length;

      if (braceCount === 0) {
        result.enums.push(currentEnum.join('\n'));
        currentEnum = [];
        inEnum = false;
      }
    } else if (inModel) {
      currentModel.push(line);
      // Count braces to handle nested field types
      braceCount += (line.match(/{/g) || []).length;
      braceCount -= (line.match(/}/g) || []).length;

      if (braceCount === 0) {
        result.models.push(currentModel.join('\n'));
        currentModel = [];
        inModel = false;
      }
    }
  }

  // Handle edge cases where file might not end properly
  if (currentEnum.length > 0) {
    console.warn(`‚ö†Ô∏è  Unclosed enum in ${fileName}`);
    result.enums.push(currentEnum.join('\n'));
  }

  if (currentModel.length > 0) {
    console.warn(`‚ö†Ô∏è  Unclosed model in ${fileName}`);
    result.models.push(currentModel.join('\n'));
  }

  return result;
}

// Helper function to validate Prisma schema syntax
function validatePrismaSchema(content: string): boolean {
  // Basic validation - check for balanced braces
  const openBraces = (content.match(/{/g) || []).length;
  const closeBraces = (content.match(/}/g) || []).length;

  if (openBraces !== closeBraces) {
    console.error(
      `‚ùå Schema validation failed: Unbalanced braces (${openBraces} vs ${closeBraces})`
    );
    return false;
  }

  return true;
}

// Run the script
if (require.main === module) {
  try {
    combinePrismaModels();
  } catch (error) {
    console.error('‚ùå Error combining models:', error);
    process.exit(1);
  }
}

export { combinePrismaModels, parsePrismaFile, validatePrismaSchema };