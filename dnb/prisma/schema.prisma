// Auto-generated by merge-prisma.ts
// Generated: 2025-12-22T12:00:00.000Z
// Updated to match actual database structure

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ========== BusinessOwner.prisma ==========
model BusinessOwner {
  id                 String   @id @default(uuid())
  userId             String   @unique
  businessName       String   @unique
  first_name         String?  @map("first_name")
  last_name          String?  @map("last_name")
  email              String   @unique
  phoneNumber        String?  @map("phoneNumber")
  registrationNumber String   @unique @map("registrationNumber")
  country            String
  state              String
  city               String
  address            String
  postalCode         String   @map("postalCode")
  planId             String?  @map("planId")
  paymentId          String?  @map("paymentId")
  status             String   @default("active")
  is_deleted         Boolean  @default(false) @map("is_deleted")
  is_verified        Boolean  @default(false) @map("is_verified")
  is_approved        Boolean  @default(false) @map("is_approved")
  createdAt          DateTime @default(now()) @map("createdAt")
  updatedAt          DateTime @updatedAt @map("updatedAt")

  // Relations
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyers      Buyer[] // Add buyers relation
  products    Product[]    @relation("BusinessOwnerProducts")
  locations   Location[]   @relation("BusinessOwnerLocations")
  offers      Offer[]      @relation("BusinessOwnerOffers")
  offerDrafts OfferDraft[] @relation("BusinessOwnerOfferDrafts")

  @@map("business_owners")
}

// ========== Buyer.prisma ==========
model Buyer {
  id                 String   @id @default(uuid())
  contactName        String
  email              String   @unique
  contactEmail       String?
  contactPhone       String?
  buyersCompanyName  String?
  productName        String?
  locationName       String?
  businessOwnerId    String
  status             String   @default("active")
  is_deleted         Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  phoneNumber        String?
  businessName       String?
  registrationNumber String?
  address            String?
  city               String?
  state              String?
  country            String   @default("India")
  postalCode         String?

  // Relations
  businessOwner BusinessOwner @relation(fields: [businessOwnerId], references: [id], onDelete: Cascade)
  offers        Offer[]       @relation("BuyerOffers")

  @@map("buyers")
}

// ========== Payment.prisma ==========
model Payment {
  id              String  @id @default(uuid())
  userId          String?
  businessOwnerId String?
  planId          String
  subscriptionId  String?

  amount   Decimal
  currency String? @default("INR")

  status        String? @default("pending")
  paymentMethod String? @default("card")

  transactionId    String? @unique
  invoicePdf       String?
  stripeSessionId  String? @unique
  stripePaymentId  String?
  stripeCustomerId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan Plan  @relation(fields: [planId], references: [id])

  @@map("payments")
}

// ========== Subscription.prisma ==========
model Subscription {
  id             String    @id @default(uuid())
  userId         String
  subscriptionId String
  planKey        String? // Added planKey to match your requirement
  planName       String
  status         String // "active", "past_due", "canceled", "trialing", "inactive"
  paymentStatus  String // "paid", "unpaid", "upgrade", "downgrade"
  startDate      DateTime
  endDate        DateTime?

  // Feature limits from plan
  maxProducts  Int?
  maxOffers    Int?
  maxBuyers    Int?
  maxLocations Int  @default(25) // Added maxLocations

  // Stripe fields
  stripeSubscriptionId String?   @unique
  stripeCustomerId     String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// ========== UserPlanUsage.prisma ==========
model UserPlanUsage {
  id            String   @id @default(uuid())
  userId        String   @unique
  planKey       String?
  usedLocations Int      @default(0)
  usedProducts  Int      @default(0)
  usedOffers    Int      @default(0)
  usedBuyers    Int      @default(0)
  lastUpdated   DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_plan_usage")
}

// ========== Plan.prisma ==========
model Plan {
  id          String @id @default(uuid())
  key         String @unique
  name        String
  description String @default("")
  currency    String @default("INR")

  priceMonthly Int
  priceYearly  Int

  maxUsers    Int @default(1)
  maxProducts Int @default(50)
  maxOffers   Int @default(100)
  maxBuyers   Int @default(50)

  features  Json @default("[]")
  trialDays Int  @default(0)

  isDefault Boolean @default(false)
  isActive  Boolean @default(true)

  sortOrder Int @default(100)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payments Payment[]

  @@map("plans")
}

// ========== Product.prisma ==========
model Product {
  id          String   @id @default(uuid())
  code        String
  productName String
  species     String[]
  size        String[]
  sku         String?
  ownerId     String
  createdAt   DateTime @default(now()) @map("createdAt")
  updatedAt   DateTime @updatedAt @map("updatedAt")

  // Relations - using ownerId to match existing table
  businessOwner      BusinessOwner       @relation("BusinessOwnerProducts", fields: [ownerId], references: [id], onDelete: Cascade)
  offerProducts      OfferProduct[]      @relation("ProductOffers")
  offerDraftProducts OfferDraftProduct[] @relation("ProductOfferDrafts")

  @@map("products")
}

// ========== Location.prisma ==========
model Location {
  id           String   @id @default(uuid())
  locationName String?
  city         String
  state        String // Added required state field
  code         String
  country      String
  address      String?
  postalCode   String?
  ownerId      String
  createdAt    DateTime @default(now()) @map("createdAt")
  updatedAt    DateTime @updatedAt @map("updatedAt")

  // Relations - using ownerId to match existing table
  businessOwner BusinessOwner @relation("BusinessOwnerLocations", fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("locations")
}

// ========== Offer.prisma ==========
model OfferDraft {
  draftNo             Int       @id @default(autoincrement()) @map("draftNo")
  businessOwnerId     String    @map("businessOwnerId")
  draftName           String?   @map("draftName")
  fromParty           String    @map("fromParty")
  origin              String
  processor           String?
  plantApprovalNumber String    @map("plantApprovalNumber")
  brand               String
  quantity            String?
  tolerance           String?
  offerValidityDate   DateTime? @map("offerValidityDate")
  shipmentDate        DateTime? @map("shipmentDate")
  paymentTerms        String?   @map("paymentTerms")
  remark              String?
  grandTotal          Decimal?  @map("grandTotal")
  status              String    @default("draft")
  isDeleted           Boolean   @default(false) @map("isDeleted")
  deletedAt           DateTime? @map("deletedAt")
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @updatedAt @map("updatedAt")

  // Relations
  businessOwner BusinessOwner       @relation("BusinessOwnerOfferDrafts", fields: [businessOwnerId], references: [id], onDelete: Cascade)
  draftProducts OfferDraftProduct[]

  @@map("offers_draft")
}

model OfferDraftProduct {
  id               String   @id @default(uuid())
  draftNo          Int      @map("draftNo") // Existing table uses camelCase
  productId        String   @map("productId") // Existing table uses camelCase
  productName      String   @map("productName") // Existing table uses camelCase
  species          String
  packing          String?
  sizeDetails      String?  @map("sizeDetails") // Existing table uses camelCase
  breakupDetails   String?  @map("breakupDetails") // Existing table uses camelCase
  priceDetails     String?  @map("priceDetails") // Existing table uses camelCase
  conditionDetails String?  @map("conditionDetails") // Existing table uses camelCase
  createdAt        DateTime @default(now()) @map("createdAt") // Existing table uses camelCase
  updatedAt        DateTime @updatedAt @map("updatedAt") // Existing table uses camelCase

  // Relations
  offerDraft   OfferDraft              @relation(fields: [draftNo], references: [draftNo], onDelete: Cascade)
  product      Product                 @relation("ProductOfferDrafts", fields: [productId], references: [id], onDelete: Cascade)
  sizeBreakups OfferDraftSizeBreakup[]

  @@map("offer_draft_products")
}

model OfferDraftSizeBreakup {
  id                  String   @id @default(uuid())
  offerDraftProductId String   @map("offerDraftProductId")
  size                String
  breakup             Int
  price               Decimal
  condition           String?
  sizeDetails         String?  @map("sizeDetails")
  breakupDetails      String?  @map("breakupDetails")
  priceDetails        String?  @map("priceDetails")
  packing             String?
  createdAt           DateTime @default(now()) @map("createdAt")
  updatedAt           DateTime @updatedAt @map("updatedAt")

  // Relations
  offerDraftProduct OfferDraftProduct @relation(fields: [offerDraftProductId], references: [id], onDelete: Cascade)

  @@map("size_breakups")
}

model Offer {
  id                  Int       @id @default(autoincrement())
  businessOwnerId     String    @map("business_owner_id")
  offerName           String    @map("offer_name")
  businessName        String    @map("business_name")
  fromParty           String    @map("from_party")
  toParty             String    @map("to_party")
  buyerId             String?   @map("buyer_id")
  origin              String
  processor           String?
  plantApprovalNumber String    @map("plant_approval_number")
  destination         String
  brand               String
  draftName           String?   @map("draft_name")
  offerValidityDate   DateTime  @map("offer_validity_date")
  shipmentDate        DateTime? @map("shipment_date")
  grandTotal          Float?    @map("grand_total")
  quantity            String?
  tolerance           String?
  paymentTerms        String?   @map("payment_terms")
  remark              String?
  status              String    @default("open")
  packing             String?
  sizeBreakups        Json      @default("[]") @map("size_breakups")
  total               Float?
  isDeleted           Boolean   @default(false) @map("is_deleted")
  deletedAt           DateTime? @map("deleted_at")
  createdAt           DateTime? @map("created_at")
  updatedAt           DateTime? @map("updated_at")

  // Relations
  businessOwner BusinessOwner  @relation("BusinessOwnerOffers", fields: [businessOwnerId], references: [id], onDelete: Cascade)
  buyer         Buyer?         @relation("BuyerOffers", fields: [buyerId], references: [id], onDelete: SetNull)
  products      OfferProduct[]

  @@map("offers")
}

model OfferProduct {
  id               String   @id @default(uuid())
  offerId          Int      @map("offerId") // Database uses camelCase
  productId        String   @map("productId") // Database uses camelCase
  productName      String   @map("productName") // Database uses camelCase
  species          String
  packing          String?
  sizeDetails      String?  @map("sizeDetails") // Database uses camelCase
  breakupDetails   String?  @map("breakupDetails") // Database uses camelCase
  priceDetails     String?  @map("priceDetails") // Database uses camelCase
  conditionDetails String?  @map("conditionDetails") // Database uses camelCase
  createdAt        DateTime @default(now()) @map("createdAt") // Database uses camelCase
  updatedAt        DateTime @updatedAt @map("updatedAt") // Database uses camelCase

  // Relations
  offer        Offer              @relation(fields: [offerId], references: [id], onDelete: Cascade)
  product      Product            @relation("ProductOffers", fields: [productId], references: [id], onDelete: Cascade)
  sizeBreakups OfferSizeBreakup[]

  @@map("offer_products")
}

model OfferSizeBreakup {
  id             String   @id @default(uuid())
  offerProductId String   @map("offerProductId") // Database uses camelCase
  size           String
  breakup        Float // Changed from Int to Float to match database (double precision)
  price          String // Changed from Decimal to String to match database
  condition      String?
  createdAt      DateTime @default(now()) @map("createdAt") // Database uses camelCase
  updatedAt      DateTime @updatedAt @map("updatedAt") // Database uses camelCase

  // Relations
  offerProduct OfferProduct @relation(fields: [offerProductId], references: [id], onDelete: Cascade)

  @@map("offer_size_breakups")
}

// ========== User.prisma ==========
model PasswordResetOtp {
  id        String   @id @default(cuid())
  email     String
  otp       String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("password_reset_otps")
}

model User {
  id               String   @id @default(uuid())
  first_name       String?  @map("first_name")
  last_name        String?  @map("last_name")
  email            String   @unique
  password         String
  roleId           Int      @map("roleId")
  businessName     String?  @map("businessName")
  created_at       DateTime @default(now()) @map("created_at")
  updated_at       DateTime @updatedAt @map("updated_at")
  stripeCustomerId String?  @map("stripeCustomerId")
  subscriptionId   String?  @map("subscriptionId")

  // Relations
  businessOwner BusinessOwner?
  payments      Payment[]
  subscriptions Subscription[]
  userPlanUsage UserPlanUsage?

  @@map("users")
}
